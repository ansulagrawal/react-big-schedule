import dayjs, { ManipulateType } from "dayjs";
import { Dayjs } from "dayjs";

import quarterOfYear from "dayjs/plugin/quarterOfYear";
import utc from "dayjs/plugin/utc";
import weekday from "dayjs/plugin/weekday";
import { RRuleSet, rrulestr } from "rrule";
import { config } from "../config/scheduler";
import behaviors, { Behaviors } from "../helper/behaviors";
import {
  ViewType,
  CellUnit,
  DATE_FORMAT,
  DATETIME_FORMAT,
} from "../config/default";
import {
  EventGroup,
  SchedulerDataConfig,
  Resource,
  HeaderEvent,
  HeadersType,
  HeaderEventsType,
  RenderDataItem,
  SlotMapItem,
  HeaderItem,
  EventItemType,
  SchedulerDataConfigOptional,
} from "../types/baseType";

export class SchedulerData {
  // localeDayjs(date?: ConfigType): Dayjs;
  // localeDayjs(date?: ConfigType, format?: OptionType, strict?: boolean): Dayjs;
  // localeDayjs(date?: ConfigType, format?: OptionType, locale?: string, strict?: boolean): Dayjs;

  cellUnit: CellUnit;
  viewType: ViewType;
  config: SchedulerDataConfig;
  resources: Resource[];
  events: EventItemType[];
  eventGroups: EventGroup<EventItemType>[];
  eventGroupsAutoGenerated: boolean;
  showAgenda: boolean;
  isEventPerspective: boolean;
  resizing: boolean;
  scrollToSpecialDayjs: boolean;
  documentWidth: number;
  behaviors: Behaviors;
  _shouldReloadViewType: boolean;
  calendarPopoverLocale: string | undefined;
  localeDayjs: typeof dayjs;
  // startDate?: string | number | Date;
  startDate: Dayjs = dayjs();
  endDate: Dayjs = dayjs();
  selectDate?: Dayjs;
  headers: HeadersType[] = [];
  renderData: RenderDataItem[] = [];

  constructor(
    date: Dayjs = dayjs(),
    viewType: ViewType = ViewType.Week,
    showAgenda: boolean = false,
    isEventPerspective: boolean = false,
    newConfig?: SchedulerDataConfigOptional,
    newBehaviors?: Behaviors
  ) {
    this.resources = [];
    this.events = [];
    this.eventGroups = [];
    this.eventGroupsAutoGenerated = true;
    this.viewType = viewType;
    this.cellUnit = viewType === ViewType.Day ? CellUnit.Hour : CellUnit.Day;
    this.showAgenda = showAgenda;
    this.isEventPerspective = isEventPerspective;
    this.resizing = false;
    this.scrollToSpecialDayjs = false;
    this.documentWidth = 0;
    this._shouldReloadViewType = false;

    this.calendarPopoverLocale = undefined;
    dayjs.extend(quarterOfYear);
    dayjs.extend(weekday);
    dayjs.extend(utc);
    this.localeDayjs = dayjs;
    this.config =
      newConfig === undefined ? config : { ...config, ...newConfig };
    this._validateMinuteStep(this.config.minuteStep);
    this.behaviors =
      newBehaviors === undefined
        ? behaviors
        : { ...behaviors, ...newBehaviors };
    this._resolveDate(0, date);
    this._createHeaders();
    this._createRenderData();
  }

  setSchedulerLocale(preset: string | ILocale) {
    if (!preset) return;

    this.localeDayjs.locale(preset);
    this._shouldReloadViewType = true;
    this.setViewType(this.viewType, this.showAgenda, this.isEventPerspective);
  }

  setCalendarPopoverLocale(lang: string) {
    if (lang) {
      this.calendarPopoverLocale = lang;
    }
  }

  setResources(resources: Resource[]) {
    this._validateResource(resources);
    this.resources = Array.from(new Set(resources));
    this._createRenderData();
    this.setScrollToSpecialDayjs(true);
  }

  setEventGroupsAutoGenerated(autoGenerated: boolean) {
    this.eventGroupsAutoGenerated = autoGenerated;
  }

  // optional
  setEventGroups(eventGroups: EventGroup<EventItemType>[]) {
    this._validateEventGroups(eventGroups);

    this.eventGroups = Array.from(new Set(eventGroups));
    console.log("eventGroup _generateEventGroups", this.eventGroups);

    this.eventGroupsAutoGenerated = false;
    this._createRenderData();
    this.setScrollToSpecialDayjs(true);
  }

  setMinuteStep(minuteStep: number) {
    if (this.config.minuteStep !== minuteStep) {
      this._validateMinuteStep(minuteStep);
      this.config.minuteStep = minuteStep;
      this._createHeaders();
      this._createRenderData();
    }
  }

  setBesidesWidth(besidesWidth: number) {
    if (besidesWidth >= 0) {
      this.config.besidesWidth = besidesWidth;
    }
  }

  getMinuteStepsInHour() {
    return 60 / this.config.minuteStep;
  }

  addResource(resource: Resource) {
    const existedResources = this.resources.filter((x) => x.id === resource.id);
    if (existedResources.length === 0) {
      this.resources.push(resource);
      this._createRenderData();
    }
  }

  addEventGroup(eventGroup: EventGroup<EventItemType>) {
    const existedEventGroups = this.eventGroups.filter(
      (x) => x.id === eventGroup.id
    );
    if (existedEventGroups.length === 0) {
      this.eventGroups.push(eventGroup);
      this._createRenderData();
    }
  }

  removeEventGroupById(eventGroupId: string) {
    let index = -1;
    this.eventGroups.forEach((item, idx) => {
      if (item.id === eventGroupId) index = idx;
    });
    if (index !== -1) this.eventGroups.splice(index, 1);
  }

  containsEventGroupId(eventGroupId: string) {
    let index = -1;
    this.eventGroups.forEach((item, idx) => {
      if (item.id === eventGroupId) index = idx;
    });
    return index !== -1;
  }

  setEvents(events: EventItemType[]) {
    console.log("events", events);
    this._validateEvents(events);
    this.events = Array.from(events);
    if (this.eventGroupsAutoGenerated) this._generateEventGroups();
    if (this.config.recurringEventsEnabled) this._handleRecurringEvents();

    this._createRenderData();
  }

  setScrollToSpecialDayjs(scrollToSpecialDayjs: boolean) {
    if (this.config.scrollToSpecialDayjsEnabled)
      this.scrollToSpecialDayjs = scrollToSpecialDayjs;
  }

  prev() {
    this._resolveDate(-1);
    this.events = [];
    this._createHeaders();
    this._createRenderData();
  }

  next() {
    this._resolveDate(1);
    this.events = [];
    this._createHeaders();
    this._createRenderData();
  }

  setDate(date: Dayjs = dayjs(new Date())) {
    this._resolveDate(0, date);
    this.events = [];
    this._createHeaders();
    this._createRenderData();
  }

  setViewType(
    viewType = ViewType.Week,
    showAgenda = false,
    isEventPerspective = false
  ) {
    this.showAgenda = showAgenda;
    this.isEventPerspective = isEventPerspective;
    this.cellUnit = CellUnit.Day;

    if (this.viewType !== viewType || this._shouldReloadViewType) {
      let date = this.startDate.clone();

      if (
        viewType === ViewType.Custom ||
        viewType === ViewType.Custom1 ||
        viewType === ViewType.Custom2
      ) {
        this.viewType = viewType;
        this._resolveDate(0, date);
      } else {
        if (this.viewType < viewType) {
          if (viewType === ViewType.Week) {
            this.startDate = date.startOf("week");
            this.endDate = this.startDate.endOf("week");
          } else if (viewType === ViewType.Month) {
            this.startDate = date.startOf("month");
            this.endDate = this.startDate.endOf("month");
          } else if (viewType === ViewType.Quarter) {
            this.startDate = date.startOf("quarter");
            this.endDate = this.startDate.endOf("quarter");
          } else if (viewType === ViewType.Year) {
            this.startDate = date.startOf("year");
            this.endDate = this.startDate.endOf("year");
          }
        } else {
          const start = this.startDate;
          const end = this.endDate.add(1, "days");

          if (this.selectDate !== undefined) {
            const selectDate = this.selectDate.clone();
            if (
              selectDate.isAfter(start) ||
              (selectDate.isSame(start) && selectDate.isBefore(end))
            ) {
              date = this.selectDate;
            }
          }

          const now = this.localeDayjs();
          if (now >= start && now < end) {
            date = now.startOf("day");
          }

          if (viewType === ViewType.Day) {
            this.startDate = date;
            this.endDate = this.startDate;
            this.cellUnit = CellUnit.Hour;
          } else if (viewType === ViewType.Week) {
            this.startDate = date.startOf("week");
            this.endDate = this.startDate.endOf("week");
          } else if (viewType === ViewType.Month) {
            this.startDate = date.startOf("month");
            this.endDate = this.startDate.endOf("month");
          } else if (viewType === ViewType.Quarter) {
            this.startDate = date.startOf("quarter");
            this.endDate = this.startDate.endOf("quarter");
          }
        }

        this.viewType = viewType;
      }

      this._shouldReloadViewType = false;

      this.events = [];
      this._createHeaders();
      this._createRenderData();
      this.setScrollToSpecialDayjs(true);
    }
  }

  setSchedulerMaxHeight(newSchedulerMaxHeight: number) {
    this.config.schedulerMaxHeight = newSchedulerMaxHeight;
  }

  isSchedulerResponsive() {
    return (
      !!this.config.schedulerWidth.endsWith &&
      this.config.schedulerWidth.endsWith("%")
    );
  }

  toggleExpandStatus(slotId: string) {
    let slotEntered = false;
    let slotIndent = -1;
    let isExpanded = false;
    const expandedMap = new Map();
    this.renderData.forEach((item) => {
      if (slotEntered === false) {
        if (item.slotId === slotId && item.hasChildren) {
          slotEntered = true;

          isExpanded = !item.expanded;
          item.expanded = isExpanded;
          slotIndent = item.indent;
          expandedMap.set(item.indent, {
            expanded: item.expanded,
            render: item.render,
          });
        }
      } else if (item.indent > slotIndent) {
        const expandStatus = expandedMap.get(item.indent - 1);
        item.render = expandStatus.expanded && expandStatus.render;

        if (item.hasChildren) {
          expandedMap.set(item.indent, {
            expanded: item.expanded,
            render: item.render,
          });
        }
      } else {
        slotEntered = false;
      }
    });
  }

  isResourceViewResponsive() {
    const resourceTableWidth = this.getResourceTableConfigWidth();
    return (
      typeof resourceTableWidth === "string" && resourceTableWidth.endsWith("%")
    );
  }

  isContentViewResponsive() {
    const contentCellWidth = this.getContentCellConfigWidth();
    return (
      typeof contentCellWidth === "string" && contentCellWidth.endsWith("%")
    );
  }

  getSchedulerWidth() {
    const baseWidth =
      this.documentWidth - this.config.besidesWidth > 0
        ? this.documentWidth - this.config.besidesWidth
        : 0;

    if (this.isSchedulerResponsive()) {
      const value =
        (baseWidth * Number(this.config.schedulerWidth.slice(0, -1))) / 100;
      // TODO: this string could be removed
      return parseInt(String(value), 10);
    } else {

      return Number(this.config.schedulerWidth);
    }
  }

  getResourceTableWidth() {
    const resourceTableConfigWidth = this.getResourceTableConfigWidth();

    const schedulerWidth = this.getSchedulerWidth();

    if (
      this.config.fixedResourceTableWidth &&
      !this.isResourceViewResponsive()
    ) {
      return parseInt("" + resourceTableConfigWidth);
    }

    let resourceTableWidth: number = (() => {
      if (this.isResourceViewResponsive()) {
        const value =
          (schedulerWidth *
            Number(String(resourceTableConfigWidth).slice(0, -1))) /
          100;

        // TODO: this string could be removed
        return parseInt(String(value), 10);
      } else {
        return Number(resourceTableConfigWidth);
      }
    })();

    if (
      this.isSchedulerResponsive() &&
      this.getContentTableWidth() + resourceTableWidth < schedulerWidth
    )
      resourceTableWidth = schedulerWidth - this.getContentTableWidth();

    return resourceTableWidth;
  }

  getContentCellWidth() {
    const contentCellConfigWidth = this.getContentCellConfigWidth();
    const schedulerWidth = this.getSchedulerWidth();

    if (this.isContentViewResponsive()) {
      const value =
        (schedulerWidth * Number(String(contentCellConfigWidth).slice(0, -1))) /
        100;
      // TODO: this string could be removed
      return parseInt(String(value), 10);
    } else {
      return Number(contentCellConfigWidth);
    }
  }

  getContentTableWidth() {
    return this.headers.length * this.getContentCellWidth();
  }

  getScrollToSpecialDayjs() {
    if (this.config.scrollToSpecialDayjsEnabled)
      return this.scrollToSpecialDayjs;
    return false;
  }

  getSlots() {
    return this.isEventPerspective ? this.eventGroups : this.resources;
  }

  getSlotById(slotId: string) {
    const slots = this.getSlots();
    let slot: Resource | EventGroup<EventItemType> | undefined;
    slots.forEach((item) => {
      if (item.id === slotId) slot = item;
    });
    return slot;
  }

  getResourceById(resourceId: string) {
    let resource;
    this.resources.forEach((item) => {
      if (item.id === resourceId) resource = item;
    });
    return resource;
  }

  getTableHeaderHeight() {
    return this.config.tableHeaderHeight;
  }

  getSchedulerContentDesiredHeight() {
    let height = 0;
    this.renderData.forEach((item) => {
      if (item.render) height += item.rowHeight;
    });
    return height;
  }

  getCellMaxEvents() {
    const viewConfigMap = {
      [ViewType.Week]: "weekMaxEvents",
      [ViewType.Day]: "dayMaxEvents",
      [ViewType.Month]: "monthMaxEvents",
      [ViewType.Year]: "yearMaxEvents",
      [ViewType.Quarter]: "quarterMaxEvents",
      [ViewType.Custom]: "customMaxEvents",
      [ViewType.Custom1]: "customMaxEvents",
      [ViewType.Custom2]: "customMaxEvents",
    } as const;

    const configProperty = viewConfigMap[this.viewType] || "customMaxEvents";
    return this.config[configProperty];
  }

  getCalendarPopoverLocale() {
    return this.calendarPopoverLocale;
  }

  getSelectedDate() {
    return this.selectDate?.format(DATE_FORMAT) || "";
  }

  getViewStartDate() {
    return this.startDate;
  }

  getViewEndDate() {
    return this.endDate;
  }

  getViewDates() {
    return {
      startDate: this.startDate,
      endDate: this.endDate,
    };
  }

  getDateLabel() {
    const start = this.startDate.clone();
    const end = this.endDate.clone();
    let dateLabel = start.format("LL");

    if (start !== end) dateLabel = `${start.format("LL")}-${end.format("LL")}`;

    if (this.behaviors.getDateLabelFunc)
      dateLabel = this.behaviors.getDateLabelFunc(
        this,
        this.viewType,
        this.startDate,
        this.endDate
      );

    return dateLabel;
  }

  addEvent(newEvent: EventItemType) {
    this._attachEvent(newEvent);
    if (this.eventGroupsAutoGenerated) this._generateEventGroups();
    this._createRenderData();
  }

  updateEventStart(event: EventItemType, newStart: Dayjs) {
    this._detachEvent(event);
    event.start = newStart;
    this._attachEvent(event);
    this._createRenderData();
  }

  updateEventEnd(event: EventItemType, newEnd: Dayjs) {
    event.end = newEnd;
    this._createRenderData();
  }

  swapEvent(eventSource: EventItemType, eventDest: EventItemType) {
    // Swap group or resource IDs
    if (this.isEventPerspective) {
      [eventSource.groupId, eventDest.groupId] = [
        eventDest.groupId,
        eventSource.groupId,
      ];
      [eventSource.groupName, eventDest.groupName] = [
        eventDest.groupName,
        eventSource.groupName,
      ];
    } else {
      [eventSource.resourceId, eventDest.resourceId] = [
        eventDest.resourceId,
        eventSource.resourceId,
      ];
    }

    // Swap start and end times
    [eventSource.start, eventDest.start] = [eventDest.start, eventSource.start];
    [eventSource.end, eventDest.end] = [eventDest.end, eventSource.end];

    // Update the events
    this._detachEvent(eventSource);
    this._detachEvent(eventDest);
    this._attachEvent(eventSource);
    this._attachEvent(eventDest);
    this._createRenderData();
  }

  swapEvent2(eventSource: EventItemType, eventDest: EventItemType) {
    const tempEventSource = { ...eventSource };
    const tempEventDest = { ...eventDest };
    this._detachEvent(eventSource);
    this._detachEvent(eventDest);
    if (this.isEventPerspective) {
      tempEventSource.groupId = eventDest.groupId;
      tempEventSource.groupName = eventDest.groupName;
      tempEventDest.groupId = eventSource.groupId;
      tempEventDest.groupName = eventSource.groupName;
    } else {
      tempEventSource.resourceId = eventDest.resourceId;
      tempEventDest.resourceId = eventSource.resourceId;
    }
    tempEventSource.end = eventDest.end;
    tempEventSource.start = eventDest.start;
    tempEventDest.end = eventSource.end;
    tempEventDest.start = eventSource.start;
    this._attachEvent(tempEventSource);
    this._attachEvent(tempEventDest);
    this._createRenderData();
  }

  moveEvent(
    event: EventItemType,
    newSlotId: string,
    newSlotName: string,
    newStart: Dayjs,
    newEnd: Dayjs
  ) {
    this._detachEvent(event);
    if (this.isEventPerspective) {
      event.groupId = newSlotId;
      event.groupName = newSlotName;
    } else event.resourceId = newSlotId;
    event.end = newEnd;
    event.start = newStart;
    this._attachEvent(event);
    this._createRenderData();
  }

  isEventInTimeWindow(
    eventStart: Dayjs,
    eventEnd: Dayjs,
    windowStart: Dayjs,
    windowEnd: Dayjs
  ) {
    return eventStart.isBefore(windowEnd) && eventEnd.isAfter(windowStart);
  }

  removeEvent(event: EventItemType) {
    const index = this.events.indexOf(event);
    if (index !== -1) {
      this.events.splice(index, 1);
      this._createRenderData();
    }
  }

  removeEventById(eventId: string) {
    let index = -1;
    this.events.forEach((item, idx) => {
      if (item.id === eventId) index = idx;
    });
    if (index !== -1) {
      this.events.splice(index, 1);
      this._createRenderData();
    }
  }

  getResourceTableConfigWidth() {
    if (this.showAgenda) {
      return this.config.agendaResourceTableWidth;
    }

    const viewConfigMap = {
      [ViewType.Week]: "weekResourceTableWidth",
      [ViewType.Day]: "dayResourceTableWidth",
      [ViewType.Month]: "monthResourceTableWidth",
      [ViewType.Year]: "yearResourceTableWidth",
      [ViewType.Quarter]: "quarterResourceTableWidth",
      [ViewType.Custom]: "customResourceTableWidth",
      [ViewType.Custom1]: "customResourceTableWidth",
      [ViewType.Custom2]: "customResourceTableWidth",
    } as const;

    const configProperty =
      viewConfigMap[this.viewType] || "customResourceTableWidth";

    return this.config[configProperty];
  }

  getContentCellConfigWidth() {
    const viewConfigMap = {
      [ViewType.Week]: "weekCellWidth",
      [ViewType.Day]: "dayCellWidth",
      [ViewType.Month]: "monthCellWidth",
      [ViewType.Year]: "yearCellWidth",
      [ViewType.Quarter]: "quarterCellWidth",
      [ViewType.Custom]: "customCellWidth",
      [ViewType.Custom1]: "customCellWidth",
      [ViewType.Custom2]: "customCellWidth",
    } as const;

    const configProperty = viewConfigMap[this.viewType] || "customCellWidth";

    return this.config[configProperty];
  }

  _setDocumentWidth(documentWidth: number) {
    if (documentWidth >= 0) {
      this.documentWidth = documentWidth;
    }
  }

  _detachEvent(event: EventItemType) {
    const index = this.events.indexOf(event);
    if (index !== -1) this.events.splice(index, 1);
  }

  _attachEvent(event: EventItemType) {
    let pos = 0;
    const eventStart = event.start;
    this.events.forEach((item, index) => {
      const start = item.start;
      if (eventStart >= start) pos = index + 1;
    });
    this.events.splice(pos, 0, event);
  }

  _handleRecurringEvents() {
    const recurringEvents = this.events.filter((x) => !!x.rrule);
    recurringEvents.forEach((item) => {
      this._detachEvent(item);
    });

    recurringEvents.forEach((item) => {
      const windowStart = this.startDate;
      const windowStartDate = windowStart.toDate();
      const windowEnd = this.endDate.add(1, "days");
      const windowEndDate = windowEnd.toDate();
      const oldStart = item.start;
      const oldEnd = item.end;
      if (item.rrule) {
        let rule = rrulestr(item.rrule);
        let oldDtstart: Dayjs | undefined;
        const oldUntil = rule.origOptions.until || windowEndDate;
        if (rule.origOptions.dtstart) {
          oldDtstart = this.localeDayjs(new Date(rule.origOptions.dtstart));
        }
        // rule.origOptions.dtstart = oldStart.toDate();
        if (windowEndDate < oldUntil) {
          rule.origOptions.until = windowEndDate;
        }

        // reload
        rule = rrulestr(rule.toString());

        if (item.exdates || item.exrule) {
          const rruleSet = new RRuleSet();
          rruleSet.rrule(rule);
          if (item.exrule) {
            rruleSet.exrule(rrulestr(item.exrule));
          }
          if (item.exdates) {
            item.exdates.forEach((exdate) => {
              rruleSet.exdate(this.localeDayjs(exdate).toDate());
            });
          }
          rule = rruleSet;
        }

        const all = rule.between(windowStartDate, windowEndDate);
        all.forEach((time, index) => {
          const newEvent = {
            ...item,
            recurringEventId: item.id,
            recurringEventStart: item.start,
            recurringEventEnd: item.end,
            id: `${item.id}-${index}`,
            start: rule.origOptions.tzid
              ? this.localeDayjs
                  .utc(time)
                  // TODO: Something is wrong here
                  .utcOffset(this.localeDayjs(new Date()).utcOffset(), true)
              : this.localeDayjs(new Date(time)),
            end: rule.origOptions.tzid
              ? this.localeDayjs
                  .utc(time)
                  // TODO: Something is wrong here
                  .utcOffset(this.localeDayjs(new Date()).utcOffset(), true)
                  .add(oldEnd.diff(oldStart), "ms")
                  .add(
                    this.localeDayjs(new Date(oldUntil)).utcOffset() -
                      item.start.utcOffset(),
                    "m"
                  )
              : this.localeDayjs(new Date(time)).add(
                  oldEnd.diff(oldStart),
                  "ms"
                ),
          };

          const eventStart = newEvent.start.clone();
          const eventEnd = newEvent.end.clone();
          if (
            this.isEventInTimeWindow(
              eventStart,
              eventEnd,
              windowStart,
              windowEnd
            ) &&
            (!oldDtstart || eventStart >= oldDtstart)
          ) {
            this._attachEvent(newEvent);
          }
        });
      }
    });
  }

  _resolveDate(num: number, date?: Dayjs) {
    if (date !== undefined) {
      this.selectDate = date.clone();
    }

    const setStartAndEndDates = (
      unit: "week" | "month" | "quarter" | "year"
    ) => {
      const unitWithType = `${unit}s` as ManipulateType;
      this.startDate =
        date !== undefined
          ? this.selectDate?.startOf(unit) ??
            this.startDate.add(num, unitWithType)
          : this.startDate.add(num, unitWithType);
      this.endDate = this.startDate.endOf(unit);
    };

    switch (this.viewType) {
      case ViewType.Week:
        setStartAndEndDates("week");
        break;

      case ViewType.Day:
        this.startDate =
          date !== undefined
            ? this.selectDate ?? this.startDate
            : this.startDate.add(num, "days");
        this.endDate = this.startDate;
        break;

      case ViewType.Month:
        setStartAndEndDates("month");
        break;

      case ViewType.Quarter:
        setStartAndEndDates("quarter");
        break;

      case ViewType.Year:
        setStartAndEndDates("year");
        break;

      case ViewType.Custom:
      case ViewType.Custom1:
      case ViewType.Custom2:
        if (this.behaviors.getCustomDateFunc !== undefined) {
          const customDate = this.behaviors.getCustomDateFunc(this, num, date);
          this.startDate = customDate.startDate.clone();
          this.endDate = customDate.endDate.clone();
          if (customDate.cellUnit) {
            this.cellUnit = customDate.cellUnit;
          }
        } else {
          throw new Error(
            "This is a custom view type, set behaviors.getCustomDateFunc func to resolve the time window (startDate and endDate) yourself"
          );
        }
        break;

      default:
        break;
    }
  }

  // Previous Code
  _createHeaders() {
    const headers = [];
    let start = this.startDate;
    let end = this.endDate;
    let header = start;

    if (this.showAgenda) {
      headers.push({
        time: header.format(DATETIME_FORMAT),
        nonWorkingTime: false,
      });
    } else if (this.cellUnit === CellUnit.Hour) {
      if (start.hour() === 0) {
        start = start.add(this.config.dayStartFrom, "hours");
      }
      if (end.hour() === 0) {
        end = end.add(this.config.dayStopTo, "hours");
      }
      header = start;

      let prevHour = -1;
      while (header >= start && header <= end) {
        // prevent doubled hours on time change
        if (header.hour() === prevHour) {
          header = header.add(1, "hours");
          // eslint-disable-next-line no-continue
          continue;
        }
        prevHour = header.hour();
        const minuteSteps = this.getMinuteStepsInHour();
        for (let i = 0; i < minuteSteps; i += 1) {
          const hour = header.hour();
          if (
            hour >= this.config.dayStartFrom &&
            hour <= this.config.dayStopTo
          ) {
            const time = header.format(DATETIME_FORMAT);
            const nonWorkingTime = this.behaviors.isNonWorkingTimeFunc(
              this,
              time
            );
            headers.push({ time, nonWorkingTime });
          }

          header = header.add(this.config.minuteStep, "minutes");
        }
      }
    } else if (this.cellUnit === CellUnit.Day) {
      while (header >= start && header <= end) {
        const time = header.format(DATETIME_FORMAT);
        const dayOfWeek = header.weekday();
        if (
          this.config.displayWeekend ||
          (dayOfWeek !== 0 && dayOfWeek !== 6)
        ) {
          const nonWorkingTime = this.behaviors.isNonWorkingTimeFunc(
            this,
            time
          );
          headers.push({ time, nonWorkingTime });
        }

        header = header.add(1, "days");
      }
    } else if (this.cellUnit === CellUnit.Week) {
      while (header >= start && header <= end) {
        const time = header.format(DATE_FORMAT);
        headers.push({ time });
        header = header.add(1, "weeks").startOf("week");
      }
    } else if (this.cellUnit === CellUnit.Month) {
      while (header >= start && header <= end) {
        const time = header.format(DATE_FORMAT);
        headers.push({ time });
        header = header.add(1, "months").startOf("month");
      }
    } else if (this.cellUnit === CellUnit.Year) {
      while (header >= start && header <= end) {
        const time = header.format(DATE_FORMAT);
        headers.push({ time });
        header = header.add(1, "years").startOf("year");
      }
    }

    this.headers = headers;
  }

  // Fix Optimited code
  // _createHeaders() {
  //   const headers = [];
  //   const start = this.localeDayjs(new Date(this.startDate));
  //   const end = this.localeDayjs(new Date(this.endDate));

  //   const processHeader = (header, format, unit, incrementFn) => {
  //     let head = header;
  //     while (head >= start && head <= end) {
  //       const time = head.format(format);
  //       if (unit === CellUnit.Day) {
  //         const dayOfWeek = head.weekday();
  //         if (this.config.displayWeekend || (dayOfWeek !== 0 && dayOfWeek !== 6)) {
  //           const nonWorkingTime = this.behaviors.isNonWorkingTimeFunc(this, time);
  //           headers.push({ time, nonWorkingTime });
  //         }
  //       } else {
  //         headers.push({ time });
  //       }
  //       head = head.add(1, incrementFn);
  //     }
  //   };

  //   if (this.showAgenda) {
  //     headers.push({ time: start.format(DATETIME_FORMAT), nonWorkingTime: false });
  //   } else if (this.cellUnit === CellUnit.Hour) {
  //     const hourIncrement = this.config.minuteStep < 60 ? 'minutes' : 'hours';
  //     const minuteSteps = this.getMinuteStepsInHour();
  //     let header = start.hour() === 0 ? start.add(this.config.dayStartFrom, 'hours') : start;
  //     while (header <= end) {
  //       const hour = header.hour();
  //       if (hour >= this.config.dayStartFrom && hour <= this.config.dayStopTo) {
  //         const time = header.format(DATETIME_FORMAT);
  //         const nonWorkingTime = this.behaviors.isNonWorkingTimeFunc(this, time);
  //         headers.push({ time, nonWorkingTime });
  //       }
  //       header = header.add(minuteSteps, hourIncrement);
  //     }
  //   } else {
  //     const header = start;
  //     const format = this.cellUnit === CellUnit.Day ? DATETIME_FORMAT : DATE_FORMAT;
  //     const incrementFn = this.cellUnit === CellUnit.Day ? 'days' : `${this.cellUnit}s`;
  //     processHeader(header, format, this.cellUnit, incrementFn);
  //   }

  //   this.headers = headers;
  // }

  _createInitHeaderEvents(header: HeadersType): HeaderEventsType {
    const start = this.localeDayjs(new Date(header.time));
    const startValue = start;

    let endValue;
    if (this.showAgenda) {
      const incrementUnit: ManipulateType = (
        {
          [ViewType.Day]: "days",
          [ViewType.Week]: "weeks",
          [ViewType.Month]: "months",
          [ViewType.Year]: "years",
          [ViewType.Quarter]: "days",
          [ViewType.Custom]: "days",
          [ViewType.Custom1]: "days",
          [ViewType.Custom2]: "days",
        } as const
      )[this.viewType];

      if (incrementUnit === "days") {
        endValue = this.endDate.clone().add(1, "days");
      } else {
        endValue = start.add(1, incrementUnit);
      }
    } else {
      const incrementUnit: ManipulateType =
        (
          {
            [CellUnit.Hour]: "minutes",
            [CellUnit.Week]: "weeks",
            [CellUnit.Month]: "months",
            [CellUnit.Year]: "years",
            [CellUnit.Day]: "days",
          } as const
        )[this.cellUnit] || "days";

      endValue = start.add(
        incrementUnit === "minutes" ? this.config.minuteStep : 1,
        incrementUnit
      );
    }

    return {
      time: header.time,
      nonWorkingTime: header.nonWorkingTime,
      start: start,
      end: endValue,
      count: 0,
      addMore: 0,
      addMoreIndex: 0,
      //  TODO: This Specifies how many rows per Resource. Allow mofication
      events: Array(3),
    };
  }

  _createHeaderEvent(render: boolean, span: number, eventItem: EventItemType) {
    return { render, span, eventItem };
  }

  _getEventSlotId(event: EventItemType) {
    return this.isEventPerspective
      ? this._getEventGroupId(event)
      : event.resourceId;
  }

  _getEventGroupId(event: EventItemType) {
    return event.groupId ? event.groupId.toString() : event.id.toString();
  }

  _getEventGroupName(event: EventItemType) {
    return event.groupName ? event.groupName : event.title;
  }

  _generateEventGroups() {
    const eventGroups: EventGroup<EventItemType>[] = [];
    const set = new Set();
    this.events.forEach((item) => {
      const groupId = this._getEventGroupId(item);
      const groupName = this._getEventGroupName(item);

      if (!set.has(groupId)) {
        eventGroups.push({
          id: groupId,
          name: groupName,
          state: item,
        });
        set.add(groupId);
      }
    });

    this.eventGroups = eventGroups;
  }

  _createInitRenderData(
    isEventPerspective: boolean,
    eventGroups: EventGroup<EventItemType>[],
    resources: Resource[],
    headers: HeadersType[]
  ) {
    const slots = isEventPerspective ? eventGroups : resources;
    const slotTree: SlotMapItem[] = [];
    const slotMap = new Map<string, SlotMapItem>();
    slots.forEach((slot) => {
      const headerEvents = headers.map((header) =>
        this._createInitHeaderEvents(header)
      );

      const slotRenderData: RenderDataItem = {
        slotId: slot.id,
        slotName: slot.name,
        slotTitle: "title" in slot ? slot.title : undefined,
        parentId: "parentId" in slot ? slot.parentId : undefined,
        groupOnly: "groupOnly" in slot ? slot.groupOnly : undefined,
        hasSummary: false,
        rowMaxCount: 0,
        rowHeight:
          this.config.nonAgendaSlotMinHeight !== 0
            ? this.config.nonAgendaSlotMinHeight
            : this.config.eventItemLineHeight + 2,
        headerItems: headerEvents,
        indent: 0,
        hasChildren: false,
        expanded: true,
        render: true,
      };

      const { id } = slot;
      let value: SlotMapItem | undefined;
      if (slotMap.has(id)) {
        value = slotMap.get(id) as SlotMapItem;
        value.data = slotRenderData;
      } else {
        value = {
          data: slotRenderData,
          children: [],
        };
        slotMap.set(id, value);
      }

      if (
        !("parentId" in slot) ||
        slot.parentId == undefined ||
        slot.parentId === id
      ) {
        slotTree.push(value);
      } else {
        let parentValue: SlotMapItem | undefined;
        if (slotMap.has(slot.parentId)) {
          parentValue = slotMap.get(slot.parentId) as SlotMapItem;
        } else {
          parentValue = {
            data: undefined,
            children: [],
          };
          slotMap.set(slot.parentId, parentValue);
        }

        parentValue.children.push(value);
      }
    });

    const slotStack: SlotMapItem[] = [];
    let i;
    for (i = slotTree.length - 1; i >= 0; i -= 1) {
      const item = slotTree[i];
      if (item) {
        slotStack.push(item);
      }
    }

    const initRenderData = [];
    let currentNode: SlotMapItem | undefined;
    while (slotStack.length > 0) {
      currentNode = slotStack.pop() as SlotMapItem;
      console.log("currentNode", currentNode);

      if (currentNode.data) {
        if (currentNode.data.indent > 0) {
          currentNode.data.render = this.config.defaultExpanded;
        }
        if (currentNode.children.length > 0) {
          currentNode.data.hasChildren = true;
          currentNode.data.expanded = this.config.defaultExpanded;
        }
        initRenderData.push(currentNode.data);

        for (i = currentNode.children.length - 1; i >= 0; i -= 1) {
          currentNode.children[i].data.indent = currentNode.data.indent + 1;
          slotStack.push(currentNode.children[i]);
        }
      }
    }
    console.log("initRenderData", initRenderData);
    return initRenderData;
  }

  _getSpan(startTime: Dayjs, endTime: Dayjs, headers: HeadersType[]) {
    if (this.showAgenda) return 1;

    // function startOfWeek(date) {
    //   const day = date.getDay();
    //   const diff = date.getDate() - day;
    //   return new Date(date.getFullYear(), date.getMonth(), diff);
    // }

    const timeBetween = (
      date1: Dayjs,
      date2: Dayjs,
      timeIn: "days" | "minute" | "minutes" | "day"
    ) => {
      if (timeIn === "days" || timeIn === "day") {
        if (date1.date() === date2.date() && date1.month() === date2.month()) {
          return 1;
        }
      }

      let one;
      switch (timeIn) {
        case "days":
        case "day":
          one = 1000 * 60 * 60 * 24;
          break;
        case "minutes":
        case "minute":
          one = 1000 * 60;
          break;
        default:
          return 0;
      }

      const date1Ms = date1.toDate().getTime();
      const date2Ms = date2.toDate().getTime();

      const diff = (date2Ms - date1Ms) / one;
      return diff < 0 ? 0 : diff;
    };

    let eventStart = startTime;
    let eventEnd = endTime;
    let span = 0;

    const windowStart = this.startDate.clone().startOf("day");
    const windowEnd = this.endDate.clone().endOf("day");
    // setHours(0, 0, 0, 0);
    // windowEnd.setHours(23, 59, 59);

    if (this.viewType === ViewType.Day) {
      if (headers.length > 0) {
        let day = this.localeDayjs(new Date(headers[0]!.time));
        if (day.date() > eventStart.date() && day.date() < eventEnd.date()) {
          span = 1440 / this.config.minuteStep;
        } else if (
          day.date() > eventStart.date() &&
          day.date() === eventEnd.date()
        ) {
          span = Math.ceil(
            timeBetween(day, eventEnd, "minutes") / this.config.minuteStep
          );
        } else if (
          day.date() === eventStart.date() &&
          day.date() < eventEnd.date()
        ) {
          day = day.endOf("day");

          span = Math.ceil(
            timeBetween(eventStart, day, "minutes") / this.config.minuteStep
          );
        } else if (
          (day.date() === eventStart.date() &&
            day.date() === eventEnd.date()) ||
          eventEnd.date() === eventStart.date()
        ) {
          span = Math.ceil(
            timeBetween(eventStart, eventEnd, "minutes") /
              this.config.minuteStep
          );
        }
      }
    } else if (
      this.viewType === ViewType.Week ||
      this.viewType === ViewType.Month ||
      this.viewType === ViewType.Quarter ||
      this.viewType === ViewType.Year
    ) {
      const startDate = windowStart.isBefore(eventStart)
        ? eventStart
        : windowStart;
      const endDate = windowEnd > eventEnd ? eventEnd : windowEnd;
      span = Math.ceil(timeBetween(startDate, endDate, "days"));
    } else {
      if (this.cellUnit === CellUnit.Day) {
        eventStart = eventStart.startOf("day");
        eventEnd = eventEnd.endOf("day");
      }

      const timeIn = this.cellUnit === CellUnit.Day ? "days" : "minutes";
      const dividedBy =
        this.cellUnit === CellUnit.Day ? 1 : this.config.minuteStep;

      if (windowStart >= eventStart && eventEnd <= windowEnd) {
        span = Math.ceil(
          timeBetween(windowStart, eventEnd, timeIn) / dividedBy
        );
      } else if (windowStart > eventStart && eventEnd > windowEnd) {
        span = Math.ceil(
          timeBetween(windowStart, windowEnd, timeIn) / dividedBy
        );
      } else if (windowStart <= eventStart && eventEnd >= windowEnd) {
        span = Math.ceil(
          timeBetween(eventStart, windowEnd, timeIn) / dividedBy
        );
      } else {
        span = Math.ceil(timeBetween(eventStart, eventEnd, timeIn) / dividedBy);
      }
    }

    return span;
  }

  _validateResource(resources: Resource[]) {
    if (Object.prototype.toString.call(resources) !== "[object Array]") {
      throw new Error("Resources should be Array object");
    }

    resources.forEach((item, index) => {
      if (item === undefined) {
        console.error(`Resource undefined: ${index}`);
        throw new Error(`Resource undefined: ${index}`);
      }
      if (item.id === undefined || item.name === undefined) {
        console.error("Resource property missed", index, item);
        throw new Error(`Resource property undefined: ${index}`);
      }
    });
  }

  _validateEventGroups(eventGroups: EventGroup<EventItemType>[]) {
    if (Object.prototype.toString.call(eventGroups) !== "[object Array]") {
      throw new Error("Event groups should be Array object");
    }

    eventGroups.forEach((item, index) => {
      if (item === undefined) {
        console.error(`Event group undefined: ${index}`);
        throw new Error(`Event group undefined: ${index}`);
      }
      if (item.id === undefined || item.name === undefined) {
        console.error("Event group property missed", index, item);
        throw new Error(`Event group property undefined: ${index}`);
      }
    });
  }

  _validateEvents(events: EventItemType[]) {
    if (Object.prototype.toString.call(events) !== "[object Array]") {
      throw new Error("Events should be Array object");
    }

    events.forEach((e, index) => {
      if (e === undefined) {
        console.error(`Event undefined: ${index}`);
        throw new Error(`Event undefined: ${index}`);
      }
      if (
        e.id === undefined ||
        e.resourceId === undefined ||
        e.title === undefined ||
        e.start === undefined ||
        e.end === undefined
      ) {
        console.error("Event property missed", index, e);
        throw new Error(`Event property undefined: ${index}`);
      }
    });
  }

  _validateMinuteStep(minuteStep: number) {
    if (60 % minuteStep !== 0) {
      console.error(
        "Minute step is not set properly - 60 minutes must be divisible without remainder by this number"
      );
      throw new Error(
        "Minute step is not set properly - 60 minutes must be divisible without remainder by this number"
      );
    }
  }

  _compare(event1: EventItemType, event2: EventItemType) {
    const start1 = event1.start.clone();
    const start2 = event2.start.clone();
    if (start1 !== start2) return start1 < start2 ? -1 : 1;

    const end1 = event1.end.clone();
    const end2 = event2.end.clone();
    if (end1 !== end2) return end1.isBefore(end2) ? -1 : 1;

    return event1.id < event2.id ? -1 : 1;
  }

  _createRenderData() {
    // Initialize render data
    const initRenderData = this._createInitRenderData(
      this.isEventPerspective,
      this.eventGroups,
      this.resources,
      this.headers
    );
    console.log("initRenderData1", initRenderData);

    // Get the maximum number of events that can be displayed in a cell
    const cellMaxEventsCount = this.getCellMaxEvents();
    console.log("cellMaxEventsCount", cellMaxEventsCount);
    const cellMaxEventsCountValue = 30;

    // Iterate over each event
    this.events.forEach((item) => {
      // Filter render data to find the resource events list for the current event
      const resourceEventsList = initRenderData.filter(
        (x) => x.slotId === this._getEventSlotId(item)
      );
      if (resourceEventsList.length > 0) {
        const resourceEvents = resourceEventsList[0] as RenderDataItem;
        const span = this._getSpan(item.start, item.end, this.headers);
        const eventStart = item.start.clone();
        const eventEnd = item.end.clone();
        let pos = -1;

        // Iterate over each header item in the resource events
        resourceEvents.headerItems.forEach((header, index) => {
          const headerStart = header.start.clone();
          const headerEnd = header.end.clone();
          if (headerEnd.isAfter(eventStart) && headerStart.isBefore(eventEnd)) {
            // Increment the count of events in the header
            header.count += 1;

            if (header.count > resourceEvents.rowMaxCount) {
              resourceEvents.rowMaxCount = header.count;
              const rowsCount =
                cellMaxEventsCount <= cellMaxEventsCountValue &&
                resourceEvents.rowMaxCount > cellMaxEventsCount
                  ? cellMaxEventsCount
                  : resourceEvents.rowMaxCount;

              console.log(
                "rowsCount",
                cellMaxEventsCount,
                cellMaxEventsCountValue,
                resourceEvents.rowMaxCount,
                cellMaxEventsCount,
                cellMaxEventsCount <= cellMaxEventsCountValue &&
                  resourceEvents.rowMaxCount > cellMaxEventsCount,
                rowsCount
              );
              const newRowHeight =
                rowsCount * this.config.eventItemLineHeight +
                (this.config.creatable && this.config.checkConflict === false
                  ? 20
                  : 2);
              if (newRowHeight > resourceEvents.rowHeight)
                resourceEvents.rowHeight = newRowHeight;
            }

            // Find the position to insert the event in the header's events array
            if (pos === -1) {
              let tmp = 0;
              while (header.events[tmp] !== undefined) tmp += 1;
              pos = tmp;
            }

            // Determine if the event should be rendered in the current header
            let render =
              headerStart.isBefore(eventStart) ||
              headerStart.isSame(eventStart) ||
              index === 0;
            if (render === false) {
              const previousHeader = resourceEvents.headerItems[index - 1];
              if (previousHeader != undefined) {
                const previousHeaderStart = previousHeader.start.clone();
                const previousHeaderEnd = previousHeader.end.clone();
                if (
                  previousHeaderEnd.isBefore(eventStart) ||
                  previousHeaderStart.isAfter(eventEnd)
                )
                  render = true;
              }
            }

            // Create and assign the header event
            header.events[pos] = this._createHeaderEvent(render, span, item);
          }
        });
      }
    });
    console.log("initRenderData2", initRenderData);

    // Handle summary and additional event rendering logic
    if (
      cellMaxEventsCount <= cellMaxEventsCountValue ||
      this.behaviors.getSummaryFunc !== undefined
    ) {
      initRenderData.forEach((resourceEvents) => {
        let hasSummary = false;

        resourceEvents.headerItems.forEach((headerItem) => {
          if (cellMaxEventsCount <= cellMaxEventsCountValue) {
            let renderItemsCount = 0;
            let addMoreIndex = 0;
            let index = 0;
            while (index < cellMaxEventsCount - 1) {
              if (headerItem.events[index] !== undefined) {
                renderItemsCount += 1;
                addMoreIndex = index + 1;
              }
              index += 1;
            }

            if (headerItem.events[index] !== undefined) {
              if (renderItemsCount + 1 < headerItem.count) {
                headerItem.addMore = headerItem.count - renderItemsCount;
                headerItem.addMoreIndex = addMoreIndex;
              }
            } else if (renderItemsCount < headerItem.count) {
              headerItem.addMore = headerItem.count - renderItemsCount;
              headerItem.addMoreIndex = addMoreIndex;
            }
          }

          // Generate summary if the summary function is defined
          if (this.behaviors.getSummaryFunc !== undefined) {
            const events: HeaderEvent[] = [];

            headerItem.events.forEach((e) => {
              if ("eventItem" in e) events.push(e);
            });

            const item = this.behaviors.getSummaryFunc(
              this,
              events,
              resourceEvents.slotId,
              resourceEvents.slotName,
              headerItem.start,
              headerItem.end
            );
            headerItem.summary = item;

            if (!!headerItem.summary && headerItem.summary.text !== undefined)
              hasSummary = true;
          }
        });

        resourceEvents.hasSummary = hasSummary;
        if (hasSummary) {
          const rowsCount =
            cellMaxEventsCount <= cellMaxEventsCountValue &&
            resourceEvents.rowMaxCount > cellMaxEventsCount
              ? cellMaxEventsCount
              : resourceEvents.rowMaxCount;
          const newRowHeight =
            (rowsCount + 1) * this.config.eventItemLineHeight +
            (this.config.creatable && this.config.checkConflict === false
              ? 20
              : 2);
          if (newRowHeight > resourceEvents.rowHeight)
            resourceEvents.rowHeight = newRowHeight;
        }
      });
    }

    console.log("this.renderData", this.renderData);
    // Assign the processed render data to the class property
    this.renderData = initRenderData;
  }

  _startResizing() {
    this.resizing = true;
  }

  _stopResizing() {
    this.resizing = false;
  }

  _isResizing() {
    return this.resizing;
  }
}
